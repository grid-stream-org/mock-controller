from random import randint, randrange, uniform, random
import datetime
import os
import time
import paho.mqtt.client as mqtt
import json
import threading
from dotenv import load_dotenv

load_dotenv()

URL = os.getenv('URL')
PORT = int(os.getenv('PORT'))
USERNAME = os.getenv('USERNAME')
PASSWORD = os.getenv('PASSWORD')

# Configuration
MAX_MESSAGES = 0  # 0 for unlimited, or set a number

# Shared message counting
total_messages = 0
messages_lock = threading.Lock()

CONTROLLERS = [
    # matthew.collett12@gmail.com
    {
        'project_id': '492e323a-b7c5-48ff-bcf7-36ffd170f409',
        'utility_id': 'utility1234',
        'baseline': 150,
        'contract_threshold': 120,
        'ders': [
            {'der_id': '11', 'type': 'battery', 'nameplate_capacity': 50},
            {'der_id': '12', 'type': 'solar', 'nameplate_capacity': 75},
            {'der_id': '13', 'type': 'battery', 'nameplate_capacity': 25}
        ]
    },
    # test@test.com
    {
        'project_id': '0b2a26cc-3573-40d6-a685-a025920bc700',
        'utility_id': 'utility1234',
        'baseline': 100,
        'contract_threshold': 80,
        'ders': [
            {'der_id': '14', 'type': 'battery', 'nameplate_capacity': 50},
            {'der_id': '15', 'type': 'solar', 'nameplate_capacity': 25},
        ]
    }
]


# Solar output algorithm generated by Claude (Anthropic, 2024)
def generate_solar_output(capacity, time_of_day=None):
    if not time_of_day:
        time_of_day = datetime.datetime.now().hour

    # Solar generation follows a more natural bell curve
    if 6 <= time_of_day <= 20:  # Daylight hours
        peak_hour = 13  # 1 PM is peak
        hour_factor = 1 - (abs(time_of_day - peak_hour) /
                           14)  # Creates bell curve
        base_output = capacity * hour_factor
        # Add some natural variation (±10%)
        return max(0, base_output * uniform(0.9, 1.1))
    return 0  # No output at night


# Battery output algorithm generated by Claude (Anthropic, 2024)
def generate_battery_output(capacity, current_soc):
    # Batteries should only discharge when SOC permits
    if current_soc < 10:  # Protection against deep discharge
        return 0

    # More granular SOC-based output
    if current_soc > 80:
        return uniform(capacity * 0.6, capacity * 0.8)
    elif current_soc > 50:
        return uniform(capacity * 0.4, capacity * 0.6)
    elif current_soc > 20:
        return uniform(capacity * 0.2, capacity * 0.4)
    else:  # Between 10% and 20%
        return uniform(capacity * 0.1, capacity * 0.2)


# EV output algorithm generated by Claude (Anthropic, 2024)
def generate_ev_output(capacity):
    # EVs either provide power or are disconnected
    is_connected = random() < 0.4  # 40% chance of being connected
    if is_connected:
        return uniform(capacity * 0.1, capacity * 0.3)
    return 0


# Power meter output algorithm generated by Claude (Anthropic, 2024)
def calculate_power_meter(base_load, der_output):
    # Power meter shows grid consumption after DER contribution
    # Add realistic noise (±2%)
    noise = uniform(-0.02, 0.02) * base_load
    return max(0, base_load - der_output + noise)


def generate_data(controller_index):
    controller = CONTROLLERS[controller_index]
    data = []
    current_time = datetime.datetime.now(datetime.timezone.utc)

    for der in controller['ders']:
        current_soc = randrange(20, 91) if der['type'] == 'battery' else 0

        if der['type'] == 'solar':
            current_output = generate_solar_output(der['nameplate_capacity'])
        elif der['type'] == 'battery':
            current_output = generate_battery_output(
                der['nameplate_capacity'], current_soc)
        else:  # ev
            current_output = generate_ev_output(der['nameplate_capacity'])

        base_load = controller['baseline'] * \
            uniform(0.9, 1.1)  # More conservative variation
        power_meter = calculate_power_meter(base_load, current_output)

        der_data = {
            "der_id": der['der_id'],
            "is_online": True,
            "timestamp": current_time.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z",
            "current_output": round(current_output, 2),
            "power_meter_measurement": round(power_meter, 2),
            "baseline": controller['baseline'],
            "contract_threshold": controller['contract_threshold'],
            "units": "kW",
            "project_id": controller['project_id'],
            "is_standalone": False,
            "connection_start_at": "2024-10-10T01:27:09.057Z",
            "current_soc": current_soc,
            "type": der['type'],  # Added type field
            "nameplate_capacity": der['nameplate_capacity']
        }
        data.append(der_data)

    return data


def should_continue(stop_event):
    global total_messages
    with messages_lock:
        if MAX_MESSAGES > 0 and total_messages >= MAX_MESSAGES:
            return False
    return not stop_event.is_set()


def run_controller(controller_index, stop_event):
    controller = CONTROLLERS[controller_index]
    client = mqtt.Client(client_id=f"controller-{controller['project_id']}")
    client.tls_set(tls_version=mqtt.ssl.PROTOCOL_TLS)
    client.username_pw_set(USERNAME, PASSWORD)

    if client.connect(URL, PORT) != 0:
        print(f"Controller {controller['project_id']} failed to connect")
        return

    client.loop_start()
    print(f"Controller {controller['project_id']} connected")

    try:
        while should_continue(stop_event):
            data = generate_data(controller_index)
            payload = json.dumps(data, indent=4)
            topic = f"projects/{controller['project_id']}"

            if client.publish(topic, payload=payload, qos=0).rc == 0:
                with messages_lock:
                    global total_messages
                    total_messages += 1
                    progress = f"({total_messages}/{MAX_MESSAGES})" if MAX_MESSAGES > 0 else total_messages
                    print(
                        f"Project {controller['project_id']} published {len(data)} DERs [Total messages: {progress}]")

            time.sleep(randint(1, 5))

    except Exception as e:
        print(f"Controller {controller['project_id']} error: {e}")
    finally:
        print(f"Controller {controller['project_id']} disconnecting...")
        client.loop_stop()
        client.disconnect()


def main():
    stop_event = threading.Event()
    threads = []

    print(f"\nStarting with:")
    print(
        f"Max messages: {'unlimited' if MAX_MESSAGES == 0 else MAX_MESSAGES}")
    print(f"Number of controllers: {len(CONTROLLERS)}\n")

    for i in range(len(CONTROLLERS)):
        thread = threading.Thread(
            target=run_controller,
            args=(i, stop_event),
            daemon=True
        )
        thread.start()
        threads.append(thread)

    try:
        # If we have a message limit, wait for completion
        if MAX_MESSAGES > 0:
            while total_messages < MAX_MESSAGES:
                time.sleep(0.1)
            stop_event.set()
        else:
            # For unlimited messages, run until interrupted
            while True:
                time.sleep(1)

    except KeyboardInterrupt:
        print("\nShutting down controllers...")
        stop_event.set()

    for thread in threads:
        thread.join(timeout=5)
    print("All controllers shut down")


if __name__ == "__main__":
    main()
